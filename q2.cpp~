#include <mutex>
#include <thread>
#include <iostream>
#include <vector>
#include <functional>
#include <chrono>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "bitset.h"
#include "mrlock.h"

#define N 1000
#define thread_num 5

MRLock<Bitset> m(1000);
int unlockVar;


template <typename T>
uint32_t lock(T * keys){
	int i;
	
	Bitset  b;
	b.Resize(1000);
	
	for(i=0;i<thread_num;i++)
	{
		b.Set(keys[i]);
	}	
	unlockVar = m.Lock(b);

}



template <typename T>
void unlock(T un){
	int i;
		
	m.Unlock(un);
}


void* test(void *args){
    int * keys= (int *)args;
    uint32_t un=lock(keys);
    usleep(rand()%200);
    unlock(un);
    pthread_exit(0);
}


int main(){

	
    int i,j;
    pthread_t *tid;
    int **keys;

    tid = (pthread_t *)malloc(sizeof(pthread_t)*thread_num);

	keys = (int**)malloc(sizeof(int *)*thread_num);
    for(i=0;i<thread_num;i++)
        keys[i]=(int*)malloc(sizeof(int)*thread_num);

    for(j=0;j<thread_num;j++)
        for(i=0;i<thread_num;i++)
            {
                keys[j][i]=((i+1)*(j+1));
               // std::cout<<keys[j][i]<<"\n";
            }

    for (i = 0; i < thread_num; i++) 
    { 
        if(pthread_create( tid + i, 0, test, (void*)keys[i]) != 0) 
        {
            perror("pthread_create() failure."); 
            exit(1); 
        } 
    } 


    for (int i = 0; i < thread_num; i++)
       pthread_join(tid[i], NULL);
    
    std::cout<<"program completed successfully"<<"\n";
    return 1;
}

